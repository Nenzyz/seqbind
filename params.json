{"name":"SeqBind","body":"SeqBind\r\n=======\r\n\r\nProblem\r\n-------\r\n\r\nDoes it bother you that some of your code looks like this?\r\n\r\n```erlang\r\n L1 = lists:map(fun (X) -> ... end, L),\r\n L2 = lists:filter(fun (X) -> ... end, L1)\r\n %% or\r\n {Q,Req1} = cowboy_http_req:qs_val(<<\"q\">>,Req),\r\n {Id,Req2} = cowboy_http_req:qs_val(<<\"id\">>,Req1)\r\n```\r\n\r\nSolution\r\n--------\r\n\r\nWhile there are some solutions available to address this, such as giving variables more descriptive names or extracting each step into a separate function, this might not be particularly  suitable for every case. Providing descriptive names still doesn't assist with reordering and having too many function calls may add complexity and unnecessary overhead.\r\n\r\nSeqBind offers a different, yet simple, solution to this problem.\r\n\r\nIt introduces the concept of sequential bindings. What is that? Sequential bindings are bindings that carry the suffix `@` (like `L@` or `Req@`) for example.\r\n\r\nSeqBind is a parse transformation that auto-numbers all occurrences of these bindings following the suffix @ (creating `L@0`, `L@1`, `Req@0`, `Req@1`) and so on.\r\n\r\nIn order to use SeqBind, one should enable the `seqbind` parse transformation, this can be done either through compiler options or by adding the line below to your module:\r\n\r\n```erlang\r\n-compile({parse_transform,seqbind}).\r\n```\r\n\r\nOne of the important properties of SeqBind is that it does not introduce any overhead (unlike some other, relatively similar solutions). Namely, it doesn't wrap anything into `fun`s but simply auto-numbers bindings. Effectively, your compiled code is no different from the original code structurally.\r\n\r\nReturning to the problem definition, this is how your code will look like with SeqBind:\r\n\r\n```erlang\r\n L@ = lists:map(fun (X) -> ... end, L@),\r\n L@ = lists:filter(fun (X) -> ... end, L@)\r\n %% or\r\n {Q,Req@} = cowboy_http_req:qs_val(<<\"q\">>,Req@),\r\n {Id,Req@} = cowboy_http_req:qs_val(<<\"id\">>,Req@)\r\n```\r\n\r\nNeat, eh?\r\n\r\n__Please__, don't use SeqBind everywhere. It is intended to be only used in those situations that really warrant its use. _Overuse of this technique will make your code look too noisy_ (`@` does stand out) and in general should be avoided as it does obscure the functional nature of Erlang.\r\n\r\nGeneral Rules\r\n---\r\n\r\nThere are few rules to be followed.\r\n\r\n### Left and Right\r\n\r\n\r\nIn the matches (such as `A@ = 1`) the side of the match is significant to SeqBind. Even though in Erlang itself it is not, this agreement allows SeqBind to do its job.\r\n\r\nThe basic idea is that if you have a sequential binding on the left, its counter will be incremented. If it's on the right, the current counter value will be used.\r\n\r\nAs a consequence of this, one should be aware, that with the commonly used syntax:\r\n\r\n```erlang\r\n#state{} = State@\r\n```\r\n\r\nNotice that because the bound variable is on the right; it will, as a result, not increment the counter for `State@` (with the noted exception of when this syntax is used in a function clause). In order to achieve the intended result, one should do:\r\n\r\n```erlang\r\nState@ = #state{}\r\n```\r\n\r\n### Matching\r\n\r\nIf instead of incrementing a sequential binding's counter you actually just want to match its value while putting it on the left side, you simply drop the suffix like so:\r\n\r\n\r\n```erlang\r\nState@ = get_state(),\r\nState = get_state_again()\r\n```\r\n\r\nThe same goes with `case`,`if` and `receive` clauses, also note that you cannot `seqbind` a variable after it has been declared, it must come first.\r\n\r\nExtra Goodies\r\n-------------\r\n\r\n### Debug helpers\r\n\r\nSeqBind has a debug helper `seqbind:i/3` that will print out the source code for a given M:F/A (provided abstract code was not removed). \r\n\r\nThis will help SeqBind users to match sequential bindings names to those they have in their debugger.\r\n\r\nExample:\r\n\r\n\r\n```erlang\r\n1> seqbind:i(seqbind_tests, multiple_assignments_test, 0).\r\nLine 5:\r\nmultiple_assignments_test() ->\r\n    A@0 = 1,\r\n    A@1 = 2,\r\n    fun(__X) ->\r\n           case A@1 of\r\n               __X ->\r\n                   ok;\r\n               __V ->\r\n                   .erlang:error({assertEqual_failed,\r\n                                  [{module,seqbind_tests},\r\n                                   {line,8},\r\n                                   {expression,\"A@\"},\r\n                                   {expected,__X},\r\n                                   {value,__V}]})\r\n           end\r\n    end(2).\r\n\r\nok\r\n```\r\n\r\n### Let syntax\r\n\r\nSeqBind also adds experimental `let` syntax in a form of a function call:\r\n\r\n```erlang\r\nA@ = 1,\r\nlet@(A@ = 2,\r\n     %% here A@ is 2\r\n    ),\r\n%% and here A@ is 1\r\n```","tagline":"Sequential Binding Parse Transformation for Erlang","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}